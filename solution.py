import pandas as pd
import numpy as np
from scipy. stats import norm
from scipy.stats import ks_2samp

chat_id = 1226526788

#def solution(x: np.array, y: np.array) -> bool:
    # Измените код этой функции
    # Это будет вашим решением
    # Не меняйте название функции и её аргументы
    #return ... # Ваш ответ, True или False
def solution(x: np.array, y: np.array) -> bool:
    '''
    Задача 2
    Перед проведением теста вы хотите убедиться в том, что рандомизатор работает верно, а именно, что сегментатор
    разбивает выборку на тест и контроль таким образом, что распределение параметра F на тесте и контроле совпадают.
    К задаче приложены 4 файла. В каждом файле каждая строка является выборкой, количество строк в каждом файле одинаково.
    В первом файле даны  данные из исторического распределения, а в остальных файлах данные, измененные разными способами.
    Ваша задача выбрать ОДИН КРИТЕРИЙ , который позволял бы отличать выборку из исторических данных от выборки
    из любого другого распределения.Входные данные: две выборки параметра F.
    Возвращаемое значение: bool-значение , ответ на вопрос "Отклонить ли гипотезу однородности выборок"
    на заданном уровне значимости.
    '''
    
    # сделаем образцовую выборку нормального распределения со средним = 0 и дисперсией =1
    pattern = norm.rvs(loc=0,scale=1,size=len(x))
    # сравним входные два массива с нашим образцовым
    pvalue1 = ks_2samp(pattern,x).pvalue
    pvalue2 = ks_2samp(pattern,y).pvalue
    if pvalue1 < 0.052 or pvalue2 < 0.052:
        return True
    
    df = pd.DataFrame({'x':x,'y':y})
    df_describe = df.describe().T
    mean_lst = list(df_describe['mean'])  # список со значением средних
    std_lst = list(df_describe['std'])  # список со значиниями дисперсий
    flag = True
    level_mean = 0.258  # пороговое значение отклонения среднего на исторических данных
    level_std = 0.1506 # пороговое значение отклонения дисперсии на исторических данных
    for i in range(len(mean_lst)):
      # если есть отклонения больше пороговых значений, то мы бракуем выборку
      if abs(mean_lst[i]) > level_mean or abs(std_lst[i] - 1) > level_std:
        flag = False
        break

    return flag    
    
